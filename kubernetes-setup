#!/bin/bash 
#
# Script to setup Kubernetes master & slave 
#
# author: Aldrin Baroi
# 
#


readonly CURRENT_DIR="$(pwd)"

readonly DEFAULT_KNODE_NAME="$(hostname)"
readonly DEFAULT_SERVICE_ACCOUNT="kubernetes-admin"
readonly DEFAULT_CLUSTER_NAME="kubernetes"
readonly DEFAULT_CONTEXT_NAME="${DEFAULT_SERVICE_ACCOUNT}@${DEFAULT_CLUSTER_NAME}"
readonly DEFAULT_LOG_DIR="${CURRENT_DIR}"
readonly DEFAULT_LOG_FILE_NAME="kubernetes-setup.log"
readonly DEFAULT_LOG_TAG="K8S Setup"

readonly PREREQUISTE_PACKAGES="openssh-server socat"
readonly NET_FILTER_MODULE_NAME="br_netfilter"
readonly SETUP_CONFIG_FILE="kubernetes-setup.conf"
readonly KSLAVE_CLUSTER_JOIN_COMMNAD_FILE="kslave-cluster-join-command"
readonly KDASHBOARD_LOGIN_INFO_FILE="kubernetes-dashboard-login.info" 
readonly KDASHBOARD_NAMESPACE="kubernetes-dashboard"

readonly VALID_USER=1
readonly INVALID_USER=0
readonly TRUE=1
readonly FALSE=0
readonly ERROR=1
readonly OK=0 

LOG_DIR="${DEFAULT_LOG_DIR}"
LOG_FILE="${LOG_DIR}/{${DEFAULT_LOG_FILE_NAME}"
LOG_TAG="${DEFAULT_LOG_TAG}"
LOG_TAG="${DEFAULT_LOG_TAG}"

KADMIN_USER="notset"
KADMIN_USER_GROUP="notset"
KADMIN_USER_HOME="notset"
KNODE_TYPE="noset"
KNODE_NAME="${DEFAULT_KNODE_NAME}"
KNODE_IFACE=""
KNODE_IP=""
KMASTER_NODE="notset"
KSLAVE_NODES="notset"

KADMIN_SERVICE_ACCOUNT=
CLUSTER_NAME=
CONTEXT_NAME=
KUBECONFIG_FILE=

SETUP_DASHBOARD=${FALSE}

LOG=TRUE

nodeType=""
nodeUser=""
REINSTALL=${FALSE}

function show_usage
{
        local msg=$1
        if [ ! -z "$msg" ]; then
                echo " "
                echo "${msg}"
                echo " "
        fi
        echo " "
        echo "kubernetes-setup usage:"
        echo " "
	echo "  kubernetes-setup -b | -j | [-s|-r] SETUP_OPTIONS | -h"
        echo " "
	echo "    -b     Get Kubenetes dashboard URL & login token"
	echo "    -j     Get slave node's cluster join command"
	echo "    -s|-r  Setup/reinstall Kubernetes node (master|slave)"
        echo "    -h     Show this usage text"
        echo " "
        echo "    SETUP_OPTIONS: -t node-type [-n node-name] [-i node-iface -a node-ip] [-c] [-d log-dir]"
        echo " "
        echo "      -t node-type    Kubernetes node type [master|slave]"
	echo "      -n node-name    Kubernetes node's host name (override config file)"
	echo "      -i node-iface   Kubernetes node's network interface name (changes node's IP address)"
	echo "      -a node-ip      IP address & netmask  Ex:  172.16.0.2/255.255.0.0"
	echo "      -c              Setup dashboard. Only applies to master node. By default dashboard is not setup"
	echo "      -d log-dir      Overrides default log directory" 
        echo " "
}

function set_log_tag
{
        LOG_TAG=$1
}

function new_log_file
{
	local backupLogFile=""
	if [ -f "${LOG_FILE}" ]; then
		backupLogFile="${LOG_FILE}-$(ls --full-time ${LOG_FILE} | awk '{ print $6"_"$7 }' | sed 's/[.].*$//')"
		if (( $(cp ${LOG_FILE} ${backupLogFile}; echo $?) )); then
			echo "WARN: Failed to create backup of the previous log file"
		fi
	fi
	if (( $(cat /dev/null > ${LOG_FILE}; echo $?) )); then
		echo "Failed to create/clear the log file [${LOG_FILE}]"
		echo "Exiting..."
		exit 1
	fi
}

function log_enable
{
	LOG=TRUE
}

function log_disable
{
	LOG=FALSE
}

function log
{
	if (( LOG )); then
		echo -e "${1}" | tee -a ${LOG_FILE} 
	else
		echo -e "${1}" 
	fi 
}

function log_pipe
{
        while read message; do
                log "${message}"
        done
}

function abort
{
        log "${1}"
        log "Aborting..."
        exit 1
}

function exeCmd
{
        local cmd=$1
	local errorMsg=$2
	local successMsg=$3 
	set -e
	set -o pipefail 
        if [ ! -z "${cmd}" ]; then
		if [ -z "${errorMsg}" ]; then
			errorMsg="Error: Command execution failed. Command: [${cmd//\"/\\\"}]"
		else
			errorMsg="${errorMsg//\"/\\\"}"
		fi
		if [ -z "${successMsg}" ]; then
			successMsg=""
		else
			successMsg="${successMsg//\"/\\\"}"
		fi
		local _CMD="${cmd}; 
		            if (( \$? )); then 
				    echo \"${errorMsg}\";
				    echo 'Aborting...';
				    exit 1;
			    else
				    if [ ! -z \"${successMsg}\" ]; then
					    echo \"${successMsg}\";
				    fi;
			    fi"
		bash -c "${_CMD}" 2>&1 | log_pipe
        fi
	set +o pipefail 
	set +e
}

function exeCmd_asAdminUser
{
        local cmd=$1
	local errorMsg=$2
	local successMsg=$3
        if [ ! -z "${cmd}" ]; then
		local _CMD="runuser -l ${KADMIN_USER} -c '${cmd}'"
		exeCmd "${_CMD}" "${errorMsg}" "${successMsg}"
        fi
} 

function yum_install
{
	local packages=$1
	exeCmd "yum install -y ${packages}" "Error: Failed to install packages: ${packages}"
} 

function yum_update
{
	exeCmd "yum update -y" "Error: Failed to update installed packages"
} 

function load_setup_configuration
{
	if [ ! -f "${SETUP_CONFIG_FILE}" ]; then
		abort "Setup configration file [${SETUP_CONFIG_FILE}] not found in the current directory."
	fi
	source ${SETUP_CONFIG_FILE} > /dev/null 2>&1
	if (( $? )); then
		abort "Failed to load setup configuration from [${SETUP_CONFIG_FILE}] file"
	fi
	KADMIN_SERVICE_ACCOUNT=${KADMIN_SERVICE_ACCOUNT:-${DEFAULT_SERVICE_ACCOUNT}}
	CLUSTER_NAME=${CLUSTER_NAME:-${DEFAULT_CLUSTER_NAME}}
	CONTEXT_NAME=${KADMIN_SERVICE_ACCOUNT}@${CLUSTER_NAME}
	KUBECONFIG_FILE=${CONTEXT_NAME}.kubeconfig
} 

function is_service_active
{
        local service=$1
        if [ ! -z ${service} ]; then
                if (( $(systemctl is-active -q ${service} > /dev/null 2>&1; echo $?) == 0 )); then
                        echo ${TRUE}
                else
                        echo ${FALSE}
                fi
        else
                echo ${FALSE}
        fi
} 

function wait_for_service_to_be_active
{
        local service=$1
	local maxCheckCount=$2
	local checkInterval=$3
        for checkCount in $(seq 1 ${maxCheckCount}); do
                if (( ! $(is_service_active ${service}) )); then
                        log "Wating ${checkInterval} seconds for ${service} to become active..."
                        sleep ${checkInterval}
                fi
        done
        if (( ! $(is_service_active ${service}) )); then
                return ${ERROR}
        fi
}


function install_required_tool__jq
{
	yum_install "epel-release"
	yum_install "jq"
}

function install_optional_tool__ifconfig
{
	yum_install "net-tools"
}

function prepare_system__set_hostname
{
	if [[ ! -z "${KNODE_NAME}" ]]; then
		log "Changing & setting host name to ${KNODE_NAME}..."
		exeCmd "hostnamectl set-hostname ${KNODE_NAME}"
	fi
}

function prepare_system__set_ip_address
{
	local ipAddress
	local netmask
	local ifcfgFile="/etc/sysconfig/network-scripts/ifcfg-${KNODE_IFACE}"
	if [[ ! -z "${KNODE_IFACE}" ]] && [[ ! -z "${KNODE_IP}" ]]; then
		log "Changing & setting IP address & netmask..."
		ipAddress=$(echo ${KNODE_IP} | awk 'BEGIN {FS="/"}; {print $1}')
		netmask=$(echo ${KNODE_IP} | awk 'BEGIN {FS="/"}; {print $2}')
		if [[ ! -z "${ipAddress}" ]] && [[ ! -z "${netmask}" ]]; then
			#exeCmd "sed -i -r 's/(IPADDR=\")(.*)(\")/\1'${ipAddress}'\3/; s/(NETMASK=\")(.*)(\")/\1'${netmask}'\3/' ${ifcfgFile}"
			exeCmd "sed -i 's/IPADDR=.*/IPADDR=${ipAddress}/; s/NETMASK=.*/NETMASK=${netmask}/' ${ifcfgFile}"
			exeCmd "systemctl restart network"
		else
			abort "Error: both ip address & netmask need to be provided. Ex:  IP_ADDRESS/NET_MASKa 172.16.0.2/255.255.0.0"
		fi
	fi
}

function is_selinux_disabled 
{
	if [ "$(getenforce)" = "Disabled" ]; then
		echo ${TRUE}
	else
		echo ${FALSE}
	fi
}

function prepare_system__disable_selinux
{
	log " "
	log "Disabling SELINUX system..."
	if (( $(is_selinux_disabled) )); then
		log "SELINUX system is already disabled."
	else
		exeCmd "setenforce 0"
		exeCmd "sed -i s/^SELINUX=enforcing$/SELINUX=permissive/ /etc/selinux/config"
	fi
}

function prepare_system__enable_bridge_network
{
	log " "
	log "Enabling bridge network... "
	log "  Setting up to load netfilter module automatically..."
	cat <<-EOF > /etc/modules-load.d/kubernetes.conf
		${NET_FILTER_MODULE_NAME}
		EOF
	log "  Loading netfilter module..."
	exeCmd "modprobe br_netfilter" 
	exeCmd "sleep 5"

	log " "
	log "  Enabling bridge network routing & ip forwarding..."
	cat <<-EOF > /usr/lib/sysctl.d/99-zz_kubernetes.conf
		net.bridge.bridge-nf-call-ip6tables = 1
		net.bridge.bridge-nf-call-iptables = 1
		net.ipv4.ip_forward = 1
		EOF
	exeCmd "sysctl --system"
	exeCmd "sleep 5"
}

function prepare_system__disable_swap_space
{
	log " "
	log "Disabling swap space..."
	exeCmd "swapoff -a"
	exeCmd "sed -i /swap/s/^/#***disabled-for-kubernetes***/ /etc/fstab"
}

function prepare_system__disable_firewall
{
	log " "
	log "Disabling firewall..."
	exeCmd "systemctl stop firewalld"
	exeCmd "systemctl disable firewalld"
	exeCmd "systemctl mask --now firewalld"
}

function prepare_system__install_required_tools
{
	log " "
	log "Installing required tool [jq]..."
	install_required_tool__jq
	log " "
	log "Installing tool [ifconfig]..."
	install_optional_tool__ifconfig
}

function prepare_system__update_hosts_file
{
	log " "
	log "Updating [/etc/hosts] file with k8s master & slave node names..."
	local hostName
	local hostShortName
	local hostIp
	local hostEntry
	local hostFile="/etc/hosts"
	if [ ! -f /etc/hosts.kubernetes-setup ]; then
		execCmd "cp /etc/hosts /etc/hosts.kubernetes-setup"
	fi
	execCmd "cp /etc/hosts.kubernetes-setup /etc/hosts"
	echo -e "#<kubernetes-setup Added by kubernetes-setup script on $(date)>"  >> ${hostFile}
	log "KNODES = ${KNODES}"
	for node in $(echo ${KNODES} | jq -cr '.[]'); do
		hostName=$(echo ${node} | jq -r ".name")
		if (( $? )); then abort "Failed to get node's host name"; fi
		hostShortName=$(echo ${hostName} | awk 'BEGIN { FS="." }; {print $1}')
		if (( $? )); then abort "failed to get node's host short name"; fi
		hostIp=$(echo ${node} | jq -r ".ipAddress")
		if (( $? )); then abort "failed to get node's ip address"; fi
		hostEntry="${hostIp}\t${hostName}\t${hostShortName}" 
		log "${hostEntry}"
		echo -e "${hostEntry}" >> ${hostFile}
	done 
	echo -e "#</kubernetes-setup>"  >> ${hostFile} 
}

function prepare_system__add_admin_user
{
	local encpw
	log ""
	log "Checking if K8S admin user [${KADMIN_USER}] exist..."
	if (( $(id -u ${KADMIN_USER} > /dev/null 2>&1; echo $?) )); then
		log "${KADMIN_USER} user doesn't exist.  Adding the user with default password: ${KADMIN_USER}." 
		encpw=$(openssl passwd -crypt ${KADMIN_PASSWORD})
		if (( $? )); then
			abort "Failed to generate encrypted passwd using openssl"
		else
			if (( $(useradd -m -p ${encpw} ${KADMIN_USER}; echo $?) )); then
				abort "Failed to add admin user"
			else
				log "Added admin user successfully."
			fi
		fi
	else
		log "Admin user exist."
	fi
	KADMIN_USER_GROUP=${KADMIN_USER}
	KADMIN_USER_HOME=$(getent passwd ${KADMIN_USER} | awk 'BEGIN {FS=":"}; {print $6}')
}

function prepare_system__update_installed_packages
{
	log "Updating already installed pacakges to the lates release."
	yum_update
}

function prepare_system
{
	log " "
	log "Preparing the system..." 
	prepare_system__set_hostname
	prepare_system__set_ip_address
	prepare_system__disable_selinux
	prepare_system__enable_bridge_network
	prepare_system__disable_swap_space
	prepare_system__disable_firewall
	prepare_system__install_required_tools
	prepare_system__update_hosts_file
	prepare_system__add_admin_user
	prepare_system__update_installed_packages
} 

function install_prerequisite_packages
{
	log " "
	log "Installing prerequisite packages"
	yum_install "${PREREQUISTE_PACKAGES}" 
}

function install_docker
{
	local callStatus
	log " "
	log "Installing & starting Docker..."
	yum_install "docker"
	exeCmd "systemctl enable --now docker"
	exeCmd "systemctl start docker"
	log "Waiting for docker service to be active..."
	wait_for_service_to_be_active "docker" 5 3
	callStatus=$?
	if (( ${callStatus} )); then
		abort "Docker failed to start within specified time limit."
	else
		log "Docker service started."
	fi 
} 

function setup_kubernetes_repository
{
	log " "
	log "Setting up kubernetes repository..."
	cat <<-EOF > /etc/yum.repos.d/kubernetes.repo
		[kubernetes]
		name=Kubernetes
		baseurl=${KUBERNETES_REPO_URL}
		enabled=1
		gpgcheck=1
		repo_gpgcheck=1
		gpgkey=${KUBERNETES_REPO_GPG_KEY_URLS}
		EOF
	yum_update
} 

function install_kubeadm_kubelet_kubectl
{
	log "Installing kubeadm, kubelet, kubectl.."
	yum_install "kubelet-${KUBERNETES_VERSION} kubeadm-${KUBERNETES_VERSION} kubectl-${KEBERNETES_VERSION} --disableexcludes=kubernetes"
	yum_update
	log "Enabling kubelet..."
	exeCmd "systemctl enable kubelet"
}

function start_kubelet 
{
	log "Starting kubelet..."
	exeCmd "systemctl start kubelet"
	log "Waiting for kubelet service to be active..."
	wait_for_service_to_be_active "kubelet" 10 5
	callStatus=$?
	if (( ${callStatus} )); then
		abort "Kubelet failed to start within specified time limit."
	else
		log "Kubelet service started."
	fi 
}

function log_start_setup
{
	log "Kubernetes ${KNODE_TYPE} node setup started."
} 

function log_end_setup
{
	log " " 
	log "Kubernetes ${KNODE_TYPE} node setup completed."
}

function setup_common_items
{
	if (( ${REINSTALL} == ${TRUE} )); then
		prepare_system__add_admin_user
	else
		prepare_system
		install_prerequisite_packages
		install_docker
		setup_kubernetes_repository
	fi
	install_kubeadm_kubelet_kubectl
}

function setup_dashboard
{
	log "Setting up Kubernetes dashboard"
	exeCmd_asAdminUser "kubectl create -f ${KUBERNETES_DASHBOARD_YAML_URL}"

	log "Exposing dashboard on NodePort..."
	exeCmd_asAdminUser "kubectl patch svc kubernetes-dashboard --type=json -p "'"[{\"op\":\"replace\",\"path\":\"/spec/type\",\"value\":\"NodePort\"}]"'" --namespace=${KDASHBOARD_NAMESPACE}"
}

function get_dashboard_url_and_login_token
{
	log " "
	log "Getting kubernetes dashboard login url & token..."
	local tmpFile="/tmp/${KDASHBOARD_LOGIN_INFO_FILE}"
	exeCmd "cat /dev/null > ${tmpFile}"
	exeCmd "chmod 666 ${tmpFile}"
	echo "#" > ${tmpFile}
	echo "# Kubernetes dashboard URL and login token" >> ${tmpFile}
	echo "#" >> ${tmpFile}
	echo " " >> ${tmpFile}
	log " "
	exeCmd_asAdminUser "k8sdbp=\$(kubectl -n ${KDASHBOARD_NAMESPACE} get service kubernetes-dashboard --no-headers | awk "'"{print \$5}"'" | sed -r "'"s/(.*[:])([0-9]+)([/].*)/\\2/"'"); echo \"The dashboard can be accessed at https://${KMASTER_IP_ADDRESS}:\${k8sdbp}\" | tee -a ${tmpFile}"
	echo " " >> ${tmpFile} 
	log " "
	exeCmd_asAdminUser "dblt=\$(kubectl get secret \$(kubectl get serviceaccount ${KADMIN_SERVICE_ACCOUNT} -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 --decode); echo \"Dashboard login token: \${dblt}\" | tee -a ${tmpFile}"
	cat ${tmpFile} > ${KDASHBOARD_LOGIN_INFO_FILE} 
	rm -f ${tmpFile} > /dev/null 
	log " "
	log "Kubernetes dashboard URL and login token has been saved in ${KDASHBOARD_LOGIN_INFO_FILE} file"
	log " "
}

function generate_slave_node_cluster_join_command
{
	cat /dev/null > ${KSLAVE_CLUSTER_JOIN_COMMNAD_FILE}
	log " "
	log "Generating slave node's cluster join command..."
	log "Slave node's cluster join command:\n"
	exeCmd "kslaveJoinCmd=\$(kubeadm token create --print-join-command); echo \${kslaveJoinCmd} | tee ${KSLAVE_CLUSTER_JOIN_COMMNAD_FILE}"
	log "\nThe join command has been saved in the ${KSLAVE_CLUSTER_JOIN_COMMNAD_FILE} file"
	log "Please copy this file over to the slave node before running Kubernetes slave node setup script."
}

function slave_node__join_cluster
{
	log "Executing cluster join command..."
	local clusterJoinCmdFile="${CURRENT_DIR}/${KSLAVE_CLUSTER_JOIN_COMMNAD_FILE}"
	exeCmd "bash ${clusterJoinCmdFile}; if (( \$? )); then echo 'Failed to join the cluster'; else echo 'Successfully joined the cluster'; fi"
}

function read_data 
{
	local dataFile=${1}
	read line < ${dataFile}
	echo ${line} 
}

function read_file
{
        local dataFile=${1}
        local line
        local fileData=""
        while read line; do
                fileData+="${line}\n"
        done < ${dataFile}
        echo ${fileData}
} 

function generate_kubeconfig_file
{
	local KADMIN_SERVICE_ACCOUNT_SECRET_NAME=""
	local KADMIN_SERVICE_ACCOUNT_CERTIFICATE=""
	local KADMIN_SERVICE_ACCOUNT_TOKEN=""
        local KUBECONFIG_DATA_FILE=/tmp/kubeconfig_data  

	# Generate service account login "kubeconfig" file
	log " "
	log "Generating service account [${KADMIN_SERVICE_ACCOUNT}] kubeconfig file: ${KUBECONFIG_FILE} ..."
	sleep 3
	log "Getting service account secret name..."
	exeCmd_asAdminUser "kubectl get serviceaccount ${KADMIN_SERVICE_ACCOUNT} -n default -o jsonpath='{.secrets[0].name}' > ${KUBECONFIG_DATA_FILE}" \
			   "Failed to get service account secret key name" 
	KADMIN_SERVICE_ACCOUNT_SECRET_NAME=$(read_data ${KUBECONFIG_DATA_FILE}) 
	log "Getting service account certificate & token..."
	exeCmd_asAdminUser "kubectl get secret ${KADMIN_SERVICE_ACCOUNT_SECRET_NAME} -n default -o json > ${KUBECONFIG_DATA_FILE}" \
			   "Failed to get service account certificate & token"
	KADMIN_SERVICE_ACCOUNT_CERTIFICATE=$(cat ${KUBECONFIG_DATA_FILE} | jq -cr .data.\"ca.crt\")
	KADMIN_SERVICE_ACCOUNT_TOKEN=$(cat ${KUBECONFIG_DATA_FILE} | jq -cr .data.token | base64 --decode) 
	rm -f ${KUBECONFIG_DATA_FILE} > /dev/null 2>&1

	cat <<-EOF > ${KUBECONFIG_FILE}
	apiVersion: v1
	kind: Config
	clusters:
	  - cluster:
	      certificate-authority-data: ${KADMIN_SERVICE_ACCOUNT_CERTIFICATE}
	      server: https://${KMASTER_IP_ADDRESS}
	    name: ${CLUSTER_NAME}
	contexts:
	  - context:
	      cluster: ${CLUSTER_NAME}
	      namespace: default
	      user: ${KADMIN_SERVICE_ACCOUNT}
	    name: ${CONTEXT_NAME}
	current-context: ${CONTEXT_NAME}
	users:
	  - name: ${KADMIN_SERVICE_ACCOUNT}
	    user:
	      token: ${KADMIN_SERVICE_ACCOUNT_TOKEN}
	EOF
}

function setup_master_node
{
	log_start_setup 
	setup_common_items

	log " "
	log "Initiating cluster..."
	exeCmd "kubeadm init --pod-network-cidr=${CALICO_NETWORK_CIDR} --apiserver-advertise-address=${KMASTER_IP_ADDRESS}"
	
	log " "
	log "Setting up KADMIN_USER (${KADMIN_USER}) environment to be able to use kubectl command"
	exeCmd_asAdminUser "mkdir -p ${KADMIN_USER_HOME}/.kube"
	exeCmd "cp /etc/kubernetes/admin.conf ${KADMIN_USER_HOME}/.kube/config"
	exeCmd "chown -R ${KADMIN_USER}:${KADMIN_USER_GROUP} /home/${KADMIN_USER}/.kube/config"

	log " "
	log "Creating service account [${KADMIN_SERVICE_ACCOUNT}]..."
	exeCmd_asAdminUser "kubectl create serviceaccount ${KADMIN_SERVICE_ACCOUNT} -n default"
	log "Adding cluster admin role binding rule..."
	exeCmd_asAdminUser "kubectl create clusterrolebinding cluster-admin-role -n default --clusterrole=cluster-admin --serviceaccount=default:${KADMIN_SERVICE_ACCOUNT}"

	log " "
	log "Generating kubeconfig file..."
	generate_kubeconfig_file
	
	log " "
	log "Setting up POD network"
	exeCmd_asAdminUser "kubectl apply -f ${CALICO_YAML_URL}" 
	start_kubelet 
	if (( ${SETUP_DASHBOARD} == ${TRUE} )); then
		setup_dashboard
		get_dashboard_url_and_login_token
	fi
	generate_slave_node_cluster_join_command 
	log_end_setup 
} 

function get_slave_node_cluster_join_command
{
	
	if [ ! -f ${KSLAVE_CLUSTER_JOIN_COMMNAD_FILE} ]; then
		clear
		log " "
		log "Slave node's cluster join command file not found."
		log "Trying to copy the file from master node..."
		scp root@${KMASTER_IP_ADDRESS}:/root/${KSLAVE_CLUSTER_JOIN_COMMNAD_FILE} . 
		if (( $? )); then
			abort "Failed to copy the salve node's cluster join command file from the master node."
		fi
	fi
}

function setup_slave_node
{
	log_start_setup 
	get_slave_node_cluster_join_command
	setup_common_items
	slave_node__join_cluster 
	start_kubelet
	log_end_setup 
}

function prepare_for_reinstall
{
	log "Disabling & stopping kubelet..."
	exeCmd 'systemctl disable kubelet'
	exeCmd 'systemctl stop kubelet'
	sleep 3
	log "Removing kubenetes..."
	exeCmd 'yum remove -y kube*'
	log "Stopping all kubernetes processes..."
	[[ $(pgrep "master") ]]    && exeCmd 'pkill master'
	[[ $(pgrep "kubelet") ]]   && exeCmd 'pkill kubelet'
	[[ $(pgrep "kube-api") ]]  && exeCmd 'pkill "kube-api*"'
	[[ $(pgrep "etcd") ]]      && exeCmd 'pkill etcd'
	log "Stopping all docker containers..." 
	if (( $(docker container ps -aq | wc -l) > 0 )); then
		exeCmd 'docker container stop $(docker container ps -aq)'
	else
		log '  No containers to stop'
	fi 
	log "Removing all docker containers..."

	if (( $(docker container ps -aq | wc -l) > 0 )); then
		exeCmd 'docker container rm $(docker container ps -aq)'
	else
		log '  No containers to remove'
	fi 
	log "Removing all docker images..."

	if (( $(docker images ls -aq | wc -l) > 0 )); then
		exeCmd 'docker images rm $(docker images ls -aq)'
	else
		log '  No images to remove'
	fi 
	log "Removing all docker volumes..."
	if (( $(docker volume ls -q | wc -l) > 0 )); then
		exeCmd 'docker volume rm $(docker volume ls -q)'
	else
		log '  No volumes to remove'
	fi 
	log "Unmounting all kubenetes tmpfs mounts..."
	if [[ $(mount -l -t tmpfs | grep kube | wc -l) > 0 ]]; then
		exeCmd 'mount -l -t tmpfs | grep kube | awk '"'"'{print $3}'"'"' | xargs -l umount -t tmpfs'
	else
		log "  No tmpfs mount to unmount"
	fi
	log "Removing all kubernetes config and other files & temporary mount points..."
	exeCmd 'rm -rf /etc/kubernetes'
	exeCmd 'rm -rf /var/lib/etcd'
	exeCmd 'rm -rf /var/lib/kube*'
}

# __main__ 

readonly OPTIONS=":bjsrt:n:i:a:cd:h"
getopts "${OPTIONS}" opt ${@}
case $opt in
	b)
		log_disable
	       	load_setup_configuration
		get_dashboard_url_and_login_token
		;;
	j)
		log_disable
	       	load_setup_configuration
		generate_slave_node_cluster_join_command
		;;
	r|s)
	       	load_setup_configuration
		if [[ "${opt}" == "r" ]]; then
			REINSTALL=${TRUE}
		fi
		nodeType=""
		nodeUser=""
                while getopts "${OPTIONS}" opt ${@}; do
                        case $opt in
                                t)
                                        nodeType=${OPTARG}
                                        ;;
                                n)
                                        nodeName=${OPTARG}
                                        ;;
                                i)
                                        nodeIface=${OPTARG}
                                        ;;
                                a)
                                        nodeIp=${OPTARG}
                                        ;;
                                c)
                                        SETUP_DASHBOARD=${TRUE}
                                        ;;
                                d)
                                        logDir=${OPTARG}
                                        ;;
				*)
					show_usage "Invalid option(s) provided"
                        esac
                done 
		KNODE_TYPE=${nodeType}
		if [[ ! -z "${nodeName}" ]]; then
			KNODE_NAME=${nodeName}
		fi
		if [[ ! -z "${nodeIface}" ]]; then
			KNODE_IFACE=${nodeIface}
		fi
		if [[ ! -z "${nodeIp}" ]]; then
			KNODE_IP=${nodeIp}
		fi
		if [[ ! -z "${nodeUser}" ]]; then
			KADMIN_USER=${nodeUser}
		fi
		LOG_TAG="K8S ${KNODE_TYPE} Setup"
		if [[ ! -z "${logDir}" ]]; then
			LOG_DIR=${logDir}
		fi
		LOG_FILE="${LOG_DIR}/setup-kuberntes-${KNODE_TYPE}.log"
		new_log_file
		if (( ${REINSTALL} == ${TRUE} )); then
			prepare_for_reinstall
		fi
		case $nodeType in 
			master)
				setup_master_node
				;;
			slave)
				setup_slave_node
				;;
			*)
				show_usage "Invalid node type: ${nodeType}"
				;;
		esac
		;;
        h|*)
                show_usage
                ;;
esac 

#::END::

